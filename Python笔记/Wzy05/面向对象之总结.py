#------面向对象------#
（1）什么时候用面向对象
----答：1.代码量大，功能多。2.处理比较复杂角色之间的关系

#------创建一个对象------#
类名()  实例化
__new__()创造了一个对象的空间，还可以做一些简单的初始化。

#------创建一个类-------#
class Leiming  语法级别，Python解释器读到就会创建一个类
type 是所有类的元类，object 是所有类的父类
类也是被创建出来的，type 创建的，我们可以指定元类 metaclass，默认是type
class A(metaclass = type):pass
type(类名) = type ,那么type就是这个类的元类。

from abc import ABCMeta, abstractmethod
class Payment(metaclass=ABCMeta):pass

上面这个抽象类的元类就是abc.ABCMeta

#---------类---------#

见图片


#---------对象---------#

类创造对象的过程就是实例化的过程：构造函数 __new__() 初始化函数 __init__()
可以通过指针（引用）找到类的空间中的内容
对象本身内部也存储了一些属于对象的属性


#---------组合------———#

一个类的对象作为另一个类对象的属性

#--------继承---------#
经典类：python2中默认类，如果继承object就是新式类
新式类：python3的类都为新式类，没有经典类

单继承和多继承
#---单继承---#
---如果子类的对象调用某个方法
------如果子类有：调用子类
---------子类有但想调用父类的：
------------super().方法名
------------类名.方法名
---如果子类没有找父类：
---一层一层往上找
#注：在任何类中调用的方法，都要自己分辨一下，这是谁的对象。


#---多继承-----#

新式类
----继承方法广度优先-C3算法，mro()可以产看继承顺序
----python3默认继承object，python2需要主动继承
----使用 super()方法，python3不需要传self和子类名，但是python2必须传

经典类
----继承方式深度优先，没有 mro()方法
----python2不继承object类，默认是经典类
----使用 super()方法，python3不需要传self和子类名，但是python2必须传


#---抽象类，接口类----#
#---多态，鸭子类型----#


#----封装，私有的----#
--广义的封装：把方法和属性都封装在一个类中，定义一个规矩来描述一类事物
--狭义的封装：私有化只能在类的内部访问
----__静态变量，私有方法，私有对象属性，私有类方法，私有静态方法
----在内存中的存储_类名__名字
----在子类中不可以访问父类的私有变量
----私有：不能在类外部使用也不能被继承

#---@property----#
装饰器函数，帮助我们将类中的方法伪装成为属性
调用方法时不用加 () 返回值找出
@方法名.setter 装饰器  修改被property装饰的属性时，调用这个方法，有两个参数，self 被修改的值
@方法名.deleter 装饰器 当要删除被property装饰的属性时，会调用这个方法。

什么时候回用到呢？
答：当使用一个属性，但是对这个属性有约束的时候。

#----classmethod 类方法装饰器-----#
推荐使用类名调用，默认传类名为第一个参数
不用对象命名空间的内容，而用到了类命名空间中的变量（静态属性），或者类方法，或者静态方法

#----staticmethod 静态方法装饰器----#
如果一个类里面的方法，即不需要用到self中的资源，也不用到cls中的资源
相当于一个普通函数
但是由于某种原因，还要把这个方法放在类中，这个时候就将这个方法变为静态方法，那么这里的某种原因是什么呢？
----答：1，完全想用面向对象编程，所有的函数都必须写在类里面
-------2，某个功能确确实实是这个类的方法，但是确确实实没有用到和这个类有关系的资源

#--------反射-------#
以某个指定的命名空间中，用字符串数据类型的变量名来获取变量的值
应用场景：
1，类名，反射 静态属性，类方法，静态方法
2，对象，反射 对象属性，方法
3，模块， 反射 模块中的方法
4.自己模块中

 1.getattr
    用法：getattr(object, name[,default]) -> value
    返回object中name字符串对应的方法和属性，不存在返回默认值default。
    如果没有传default，那么找不到就会报错
 2.hasattr
    用法：hasattr(object, name) #判断object中有没有一个name字符串对应的方法和属性
                                #如果存在返回True，不存在返回False，一般与getattr配合使用

 3.setattr
    用法：setattr(object, name, value)
    修改object中name字符串对应的属性name变为value
 4.delattr
    用法：delattr(object, name)
    删除object中name字符串对应的属性和方法                 
用反射的必要条件：变量名只能拿到一个字符串  1，从文件中拿 2，交互拿input/网络传输

#------内置方法、魔法方法，双下方法-----#
__名字__不是被直接调用的
间接调用，内置方法、面向对象中特殊语法，Python提供的语法糖